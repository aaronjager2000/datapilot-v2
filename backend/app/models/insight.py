"""
Insight model - represents AI-generated insights about dataset data.

Insights are automatically generated observations, trends, anomalies, and
recommendations discovered through LLM analysis or rule-based systems.
"""

from enum import Enum as PyEnum
from typing import Optional, TYPE_CHECKING
from datetime import datetime

from sqlalchemy import String, Text, Float, Enum, ForeignKey, CheckConstraint
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import BaseModel

if TYPE_CHECKING:
    from app.models.dataset import Dataset
    from app.models.visualization import Visualization


class InsightType(str, PyEnum):
    """Types of insights that can be generated."""
    TREND = "trend"                      # Patterns over time or ordered data
    ANOMALY = "anomaly"                  # Outliers or unusual values
    CORRELATION = "correlation"          # Relationships between variables
    SUMMARY = "summary"                  # Statistical summaries
    RECOMMENDATION = "recommendation"    # Actionable suggestions


class InsightGenerator(str, PyEnum):
    """Method used to generate the insight."""
    LLM = "llm"                         # Generated by Large Language Model
    RULE_BASED = "rule_based"           # Generated by rule-based system


class Insight(BaseModel):
    """
    Insight model - represents AI-generated data insights.

    Insights are automatically discovered observations, patterns, and
    recommendations about dataset data, generated by LLMs or rule-based systems.
    """

    __tablename__ = "insights"

    # Dataset Reference
    dataset_id: Mapped[UUID] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("datasets.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
        comment="Dataset this insight is about"
    )

    # Insight Classification
    insight_type: Mapped[InsightType] = mapped_column(
        Enum(InsightType, name="insight_type_enum"),
        nullable=False,
        index=True,
        comment="Type of insight (trend, anomaly, correlation, summary, recommendation)"
    )

    generated_by: Mapped[InsightGenerator] = mapped_column(
        Enum(InsightGenerator, name="insight_generator_enum"),
        nullable=False,
        index=True,
        comment="Method used to generate this insight (LLM or rule-based)"
    )

    # Insight Content
    title: Mapped[str] = mapped_column(
        String(500),
        nullable=False,
        comment="Brief title summarizing the insight"
    )

    description: Mapped[str] = mapped_column(
        Text,
        nullable=False,
        comment="Detailed description of the insight (often LLM-generated)"
    )

    # Confidence and Supporting Data
    confidence: Mapped[float] = mapped_column(
        Float,
        nullable=False,
        comment="Confidence score from 0.0 to 1.0"
    )

    data_support: Mapped[dict] = mapped_column(
        JSONB,
        nullable=False,
        default=dict,
        comment="Data points, statistics, and evidence supporting this insight"
    )
    """
    Data support structure examples:

    For TREND:
    {
        "column": "revenue",
        "direction": "increasing",
        "rate_of_change": 0.15,
        "time_period": "2023-01 to 2023-12",
        "sample_values": [100, 110, 125, 140, 155]
    }

    For ANOMALY:
    {
        "column": "transaction_amount",
        "anomalies": [
            {"value": 10000, "expected_range": [100, 500], "row_number": 42}
        ],
        "method": "z_score",
        "threshold": 3.0
    }

    For CORRELATION:
    {
        "column1": "marketing_spend",
        "column2": "sales_revenue",
        "coefficient": 0.85,
        "p_value": 0.001,
        "sample_size": 100
    }

    For SUMMARY:
    {
        "columns": ["age", "income"],
        "statistics": {
            "age": {"mean": 35.2, "median": 33, "std": 12.5},
            "income": {"mean": 65000, "median": 58000, "std": 25000}
        }
    }

    For RECOMMENDATION:
    {
        "based_on": "sales_trend_analysis",
        "impact_estimate": "high",
        "effort_estimate": "medium",
        "expected_outcome": "15% increase in efficiency"
    }
    """

    # Optional Action Recommendation
    suggested_action: Mapped[Optional[str]] = mapped_column(
        Text,
        nullable=True,
        comment="Actionable recommendation based on this insight"
    )

    # Optional Visualization Reference
    visualization_id: Mapped[Optional[UUID]] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("visualizations.id", ondelete="SET NULL"),
        nullable=True,
        index=True,
        comment="Optional visualization that illustrates this insight"
    )

    # Relationships
    dataset: Mapped["Dataset"] = relationship(
        "Dataset",
        foreign_keys=[dataset_id],
        back_populates="insights"
    )

    visualization: Mapped[Optional["Visualization"]] = relationship(
        "Visualization",
        foreign_keys=[visualization_id],
        back_populates="insights"
    )

    # Constraints
    __table_args__ = (
        CheckConstraint(
            "confidence >= 0.0 AND confidence <= 1.0",
            name="check_confidence_range"
        ),
        {"comment": "Insight table for multi-tenant data"},
    )

    def __repr__(self) -> str:
        return f"<Insight(id={self.id}, type={self.insight_type.value}, dataset_id={self.dataset_id}, confidence={self.confidence:.2f})>"

    @property
    def is_high_confidence(self) -> bool:
        """Check if insight has high confidence (>= 0.75)."""
        return self.confidence >= 0.75

    @property
    def is_medium_confidence(self) -> bool:
        """Check if insight has medium confidence (0.5 <= confidence < 0.75)."""
        return 0.5 <= self.confidence < 0.75

    @property
    def is_low_confidence(self) -> bool:
        """Check if insight has low confidence (< 0.5)."""
        return self.confidence < 0.5

    @property
    def confidence_level(self) -> str:
        """Get human-readable confidence level."""
        if self.is_high_confidence:
            return "high"
        elif self.is_medium_confidence:
            return "medium"
        else:
            return "low"

    @property
    def has_visualization(self) -> bool:
        """Check if insight has an associated visualization."""
        return self.visualization_id is not None

    @property
    def has_action(self) -> bool:
        """Check if insight includes a suggested action."""
        return self.suggested_action is not None and len(self.suggested_action.strip()) > 0

    @property
    def is_llm_generated(self) -> bool:
        """Check if insight was generated by an LLM."""
        return self.generated_by == InsightGenerator.LLM

    @property
    def is_rule_based(self) -> bool:
        """Check if insight was generated by rule-based system."""
        return self.generated_by == InsightGenerator.RULE_BASED

    def get_support_field(self, field: str, default=None):
        """
        Get a specific field from data_support.

        Args:
            field: Field name to retrieve
            default: Default value if field doesn't exist

        Returns:
            Field value or default
        """
        return self.data_support.get(field, default)

    def add_support_field(self, field: str, value):
        """
        Add or update a field in data_support.

        Args:
            field: Field name
            value: Value to set
        """
        if self.data_support is None:
            self.data_support = {}
        self.data_support[field] = value

    def to_summary_dict(self) -> dict:
        """
        Convert insight to a summary dictionary suitable for API responses.

        Returns:
            Dictionary with key insight information
        """
        return {
            "id": str(self.id),
            "type": self.insight_type.value,
            "title": self.title,
            "description": self.description,
            "confidence": self.confidence,
            "confidence_level": self.confidence_level,
            "has_visualization": self.has_visualization,
            "has_action": self.has_action,
            "generated_by": self.generated_by.value,
            "created_at": self.created_at.isoformat() if self.created_at else None
        }

    @classmethod
    def create_trend_insight(
        cls,
        dataset_id: UUID,
        organization_id: UUID,
        title: str,
        description: str,
        confidence: float,
        column: str,
        direction: str,
        rate_of_change: float,
        generated_by: InsightGenerator = InsightGenerator.RULE_BASED
    ) -> "Insight":
        """
        Factory method to create a trend insight.

        Args:
            dataset_id: Dataset UUID
            organization_id: Organization UUID
            title: Insight title
            description: Insight description
            confidence: Confidence score (0-1)
            column: Column name showing trend
            direction: Trend direction (increasing/decreasing/stable)
            rate_of_change: Rate of change value
            generated_by: Generation method

        Returns:
            New Insight instance
        """
        return cls(
            dataset_id=dataset_id,
            organization_id=organization_id,
            insight_type=InsightType.TREND,
            title=title,
            description=description,
            confidence=confidence,
            generated_by=generated_by,
            data_support={
                "column": column,
                "direction": direction,
                "rate_of_change": rate_of_change
            }
        )

    @classmethod
    def create_anomaly_insight(
        cls,
        dataset_id: UUID,
        organization_id: UUID,
        title: str,
        description: str,
        confidence: float,
        column: str,
        anomalies: list[dict],
        method: str,
        generated_by: InsightGenerator = InsightGenerator.RULE_BASED
    ) -> "Insight":
        """
        Factory method to create an anomaly insight.

        Args:
            dataset_id: Dataset UUID
            organization_id: Organization UUID
            title: Insight title
            description: Insight description
            confidence: Confidence score (0-1)
            column: Column containing anomalies
            anomalies: List of anomaly records
            method: Detection method used
            generated_by: Generation method

        Returns:
            New Insight instance
        """
        return cls(
            dataset_id=dataset_id,
            organization_id=organization_id,
            insight_type=InsightType.ANOMALY,
            title=title,
            description=description,
            confidence=confidence,
            generated_by=generated_by,
            data_support={
                "column": column,
                "anomalies": anomalies,
                "method": method
            }
        )

    @classmethod
    def create_correlation_insight(
        cls,
        dataset_id: UUID,
        organization_id: UUID,
        title: str,
        description: str,
        confidence: float,
        column1: str,
        column2: str,
        coefficient: float,
        generated_by: InsightGenerator = InsightGenerator.RULE_BASED
    ) -> "Insight":
        """
        Factory method to create a correlation insight.

        Args:
            dataset_id: Dataset UUID
            organization_id: Organization UUID
            title: Insight title
            description: Insight description
            confidence: Confidence score (0-1)
            column1: First column name
            column2: Second column name
            coefficient: Correlation coefficient
            generated_by: Generation method

        Returns:
            New Insight instance
        """
        return cls(
            dataset_id=dataset_id,
            organization_id=organization_id,
            insight_type=InsightType.CORRELATION,
            title=title,
            description=description,
            confidence=confidence,
            generated_by=generated_by,
            data_support={
                "column1": column1,
                "column2": column2,
                "coefficient": coefficient
            }
        )
